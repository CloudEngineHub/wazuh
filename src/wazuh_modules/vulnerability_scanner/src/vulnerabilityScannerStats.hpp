/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * Jan 1, 2025.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "json.hpp"
#include "singleton.hpp"
#include <fstream>
#include <mutex>
#include <string>

#ifndef VULNERABILITY_SCANNER_STATS_HPP
#define VULNERABILITY_SCANNER_STATS_HPP

enum VULNERABILITY_SCANNER_STATS_TYPE : int
{
    PROCESSED = 0,
    PROCESSED_DELAYED,
    PACKAGE_INSERT,
    PACKAGE_DELETE,
    OS_EVENT,
    HOTFIX_INSERT,
    HOTFIX_DELETE,
    INTEGRITY_CLEAR,
    RESCAN_ALL_AGENTS,
    RESCAN_SINGLE_AGENT,
    CLEANUP_ALL_AGENT_DATA,
    CLEANUP_SINGLE_AGENT_DATA,
    GLOBAL_SYNC_INVENTORY,
    POSTPONED,
    DELAYED,
    DELAYED_RESCAN,
    REPORTS,
    CONTENT_REBOOT,
    OS_DATA_CACHE_MISS,
    REMEDIATION_CACHE_MISS,
    STATS_ENUM_SIZE
};

/**
 * @brief This class will store the statistics of the vulnerability scanner.
 *
 */
class VulnerabilityScannerStats : public Singleton<VulnerabilityScannerStats>
{
private:
    std::mutex m_mutex;
    std::vector<std::pair<std::string, unsigned long long int>> m_statsKeyValues;
    nlohmann::json m_jsonStats;

public:
    VulnerabilityScannerStats()
        : m_statsKeyValues {{"processed", 0},
                            {"processed_delayed", 0},
                            {"package_insert", 0},
                            {"package_delete", 0},
                            {"os_event", 0},
                            {"hotfix_insert", 0},
                            {"hotfix_delete", 0},
                            {"integrity_clear", 0},
                            {"rescan_all_agents", 0},
                            {"rescan_single_agent", 0},
                            {"cleanup_all_agent_data", 0},
                            {"cleanup_single_agent_data", 0},
                            {"global_sync_inventory", 0},
                            {"postponed", 0},
                            {"delayed", 0},
                            {"delayed_rescan", 0},
                            {"reports", 0},
                            {"content_reboot", 0},
                            {"os_data_cache_miss", 0},
                            {"remediation_cache_miss", 0}}
    {
    }

    /**
     * @brief Increase in one the corresponding counter.
     *
     * @param key The key of the counter to increase.
     */
    void increment(VULNERABILITY_SCANNER_STATS_TYPE key)
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        ++m_statsKeyValues[key].second;
    }

    /**
     * @brief Returns a string with the statistics in JSON format.
     *
     * @return std::string
     */
    std::string dump()
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            for (int i = 0; i < VULNERABILITY_SCANNER_STATS_TYPE::STATS_ENUM_SIZE; ++i)
            {
                auto& [key, value] = m_statsKeyValues[i];
                m_jsonStats[key] = value;
            }
        }

        return m_jsonStats.empty() ? "{}" : m_jsonStats.dump(4);
    }

    /**
     * @brief Dump the statistics to a file.
     *
     * @param path The path of the file to save the statistics.
     */
    void saveToFile(const std::string& path)
    {
        std::ofstream file(path);
        if (file.is_open())
        {
            file << "## Vulnerability Scanner Stats ##\n";
            file << dump();
            file << "\n";
            file.close();
        }
    }

    /**
     * @brief Restores all the counters to zero.
     *
     */
    void clear()
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        for (int i = 0; i < VULNERABILITY_SCANNER_STATS_TYPE::STATS_ENUM_SIZE; ++i)
        {
            m_statsKeyValues[i].second = 0;
        }
    }
};

#endif // VULNERABILITY_SCANNER_STATS_HPP
