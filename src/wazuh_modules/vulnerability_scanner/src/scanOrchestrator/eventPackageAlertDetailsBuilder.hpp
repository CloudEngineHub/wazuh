/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 4, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_PACKAGE_ALERT_DETAILS_BUILDER_HPP
#define _EVENT_PACKAGE_ALERT_DETAILS_BUILDER_HPP

#include "alert.hpp"
#include "chainOfResponsability.hpp"
#include "databaseFeedManager.hpp"
#include "descriptionsHelper.hpp"
#include "fieldAlertHelper.hpp"
#include "globalData.hpp"
#include "numericHelper.h"
#include "scanContext.hpp"
#include <tracy/Tracy.hpp>

/**
 * @brief TEventPackageAlertDetailsBuilder class.
 * This method is responsible for generating alerts based on the scan context.
 * It will generate alerts for real time events, aka dbsync deltas.
 * Its neccessary to have the context->m_elements populated with the cve and the operation.
 * The operation can be "DELETED" or "INSERTED".
 * Its also necessary to have the context->m_matchConditions populated with the cve and the condition.
 * The condition can be "LessThanOrEqual", "LessThan", "DefaultStatus" or "Equal".
 *
 * @tparam TDatabaseFeedManager database feed manager type.
 * @tparam TScanContext scan context type.
 * @tparam TGlobalData global data type.
 */
template<typename TDatabaseFeedManager = DatabaseFeedManager,
         typename TScanContext = ScanContext,
         typename TGlobalData = GlobalData>
class TEventPackageAlertDetailsBuilder final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;

public:
    // LCOV_EXCL_START
    /**
     * @brief EventPackageAlertDetailsBuilder constructor.
     *
     * @param databaseFeedManager Database feed manager.
     */
    explicit TEventPackageAlertDetailsBuilder(std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager)
        : m_databaseFeedManager(databaseFeedManager)
    {
    }

    /**
     * @brief Class destructor.
     *
     */
    ~TEventPackageAlertDetailsBuilder() = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param context Scan context.
     * @return std::shared_ptr<ScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> context) override
    {
        ZoneScoped;
        // We only generate alerts for real time events, aka dbsync deltas.
        if (context->messageType() == MessageType::Delta)
        {
            const auto descriptionSources =
                DescriptionsHelper::cvssAndDescriptionSources<TGlobalData>(context->m_vulnerabilitySource);
            for (const auto& [cve, elementData] : context->m_elements)
            {
                try
                {
                    DescriptionsHelper::vulnerabilityDescription<TDatabaseFeedManager, TGlobalData>(
                        cve,
                        descriptionSources,
                        m_databaseFeedManager,
                        [&](const CveDescription& description)
                        {
                            const auto& operation = elementData.at("operation").template get_ref<const std::string&>();
                            const auto elementOperation {operation.compare("DELETED") == 0 ? ElementOperation::Delete
                                                         : operation.compare("INSERTED") == 0
                                                             ? ElementOperation::Insert
                                                             : ElementOperation::Unknown};

                            const std::string cvssVersion {description.scoreVersion};
                            const std::string scoreVersion {"cvss" + cvssVersion.substr(0, 1)};
                            JsonAlert alert;

                            if (elementOperation == ElementOperation::Insert)
                            {
                                if (!cvssVersion.empty())
                                {
                                    if (scoreVersion.compare("cvss2") == 0)
                                    {
                                        CVSS2 cvssVectorObj;
                                        cvssVectorObj.access_complexity = description.accessComplexity;
                                        cvssVectorObj.authentication = description.authentication;
                                        cvssVectorObj.availability = description.availabilityImpact;
                                        cvssVectorObj.confidentiality_impact = description.confidentialityImpact;
                                        cvssVectorObj.integrity_impact = description.integrityImpact;
                                        alert.vulnerability.cvss.cvss2.vector = cvssVectorObj;
                                    }
                                    else if (scoreVersion.compare("cvss3") == 0)
                                    {
                                        CVSS3 cvssVectorObj;
                                        cvssVectorObj.attack_vector = description.attackVector;
                                        cvssVectorObj.privileges_required = description.privilegesRequired;
                                        cvssVectorObj.scope = description.scope;
                                        cvssVectorObj.user_interaction = description.userInteraction;
                                        cvssVectorObj.availability = description.availabilityImpact;
                                        cvssVectorObj.confidentiality_impact = description.confidentialityImpact;
                                        cvssVectorObj.integrity_impact = description.integrityImpact;
                                        alert.vulnerability.cvss.cvss3.vector = cvssVectorObj;
                                    }
                                }

                                alert.vulnerability.assigner = description.assignerShortName;
                                alert.vulnerability.cwe_reference = description.cweId;
                                alert.vulnerability.package.source = context->packageSource();
                                alert.vulnerability.rationale = description.description;

                                const auto generateTitle = [&context, &cve]()
                                {
                                    // title = CVE-XXXX-XXXX affects <package name>
                                    std::string title {cve};
                                    title.append(" affects ");
                                    title.append(context->packageName());
                                    return title;
                                };
                                alert.vulnerability.title = generateTitle();
                                alert.vulnerability.status = "Active";
                            }
                            else if (elementOperation == ElementOperation::Delete)
                            {
                                const auto generateTitle = [&context, &cve]()
                                {
                                    // title = CVE-XXXX-XXXX affecting <package name> was solved
                                    std::string title {cve};
                                    title.append(" affecting ");
                                    title.append(context->packageName());
                                    title.append(" was solved");
                                    return title;
                                };
                                alert.vulnerability.title = generateTitle();
                                alert.vulnerability.status = "Solved";
                            }
                            else
                            {
                                throw std::runtime_error("Unknown element operation");
                            }
                            alert.vulnerability.cve = cve;
                            if (!cvssVersion.empty())
                            {
                                if (scoreVersion.compare("cvss2") == 0)
                                {
                                    alert.vulnerability.cvss.cvss2.base_score =
                                        Utils::floatToDoubleRound(description.scoreBase, 2);
                                }
                                else if (scoreVersion.compare("cvss3") == 0)
                                {
                                    alert.vulnerability.cvss.cvss3.base_score =
                                        Utils::floatToDoubleRound(description.scoreBase, 2);
                                }
                                else
                                {
                                    throw std::runtime_error("Unknown CVSS version");
                                }
                            }

                            alert.vulnerability.enumeration = "CVE";
                            alert.vulnerability.package.architecture = context->packageArchitecture();
                            alert.vulnerability.package.name = context->packageName();
                            alert.vulnerability.package.version = context->packageVersion();
                            alert.vulnerability.published = description.datePublished;
                            alert.vulnerability.reference = description.reference;
                            alert.vulnerability.severity = FieldAlertHelper::fillEmptyOrNegative(
                                Utils::toSentenceCase(description.severity.data()));
                            alert.vulnerability.classification =
                                FieldAlertHelper::fillEmptyOrNegative(description.classification);

                            alert.vulnerability.score.base = FieldAlertHelper::fillEmptyOrNegative(
                                Utils::floatToDoubleRound(description.scoreBase, 2));
                            alert.vulnerability.score.version =
                                FieldAlertHelper::fillEmptyOrNegative(description.scoreVersion);

                            // The title is different depending on the type of the alert.
                            alert.vulnerability.type = "Packages";
                            alert.vulnerability.updated = description.dateUpdated;

                            if (const auto it = context->m_matchConditions.find(cve);
                                it != context->m_matchConditions.end())
                            {
                                if (it->second.condition == MatchRuleCondition::LessThanOrEqual)
                                {
                                    alert.vulnerability.package.condition =
                                        "Package less than or equal to " + it->second.version;
                                }
                                else if (it->second.condition == MatchRuleCondition::LessThan)
                                {
                                    alert.vulnerability.package.condition = "Package less than " + it->second.version;
                                }
                                else if (it->second.condition == MatchRuleCondition::DefaultStatus)
                                {
                                    alert.vulnerability.package.condition = "Package default status";
                                }
                                else if (it->second.condition == MatchRuleCondition::Equal)
                                {
                                    alert.vulnerability.package.condition = "Package equal to " + it->second.version;
                                }
                                else
                                {
                                    logDebug2(WM_VULNSCAN_LOGTAG, "Unknown match condition");
                                }
                            }
                            context->m_alerts[cve] = serializeToJSON(alert);
                        });
                }
                catch (const std::exception& e)
                {
                    logError(WM_VULNSCAN_LOGTAG, "Error building event details for CVE: %s", cve.data());
                    logError(WM_VULNSCAN_LOGTAG, "Error message: %s", e.what());
                }
            }
        }
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(context));
    }
};

using EventPackageAlertDetailsBuilder = TEventPackageAlertDetailsBuilder<>;

#endif // _EVENT_PACKAGE_ALERT_DETAILS_BUILDER_HPP
