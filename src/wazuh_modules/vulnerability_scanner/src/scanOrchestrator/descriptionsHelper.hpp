/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * September 22, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */
#ifndef _DESCRIPTIONS_HELPER_HPP
#define _DESCRIPTIONS_HELPER_HPP

#include "databaseFeedManager.hpp"
#include "globalData.hpp"
#include "json.hpp"
#include <string>

/**
 * @brief A structure that represents a detailed CVE (Common Vulnerabilities and Exposures) description.
 *
 * This structure is designed to hold various descriptive and impactful information related to a CVE entry.
 * It contains details such as the severity of the vulnerability, relevant metrics, classification, and dates,
 * as well as metadata such as the assigner and references.
 *
 * @details
 * The structure uses `std::string_view` for most of the fields to provide an efficient, non-owning view into
 * strings, which minimizes memory copying and management overhead. The `scoreBase` is a float initialized to 0.0
 * to represent the base score of the vulnerability.
 */
struct CveDescription final
{
    /**
     * @brief The complexity of exploiting the vulnerability.
     *
     * Describes the ease or difficulty of exploiting the vulnerability. Higher complexity means more difficult
     * exploitation.
     */
    std::string_view accessComplexity;

    /**
     * @brief Short name of the entity that assigned the CVE identifier.
     *
     * This is the abbreviated name of the organization responsible for assigning the CVE.
     */
    std::string_view assignerShortName;

    /**
     * @brief The vector used to exploit the vulnerability.
     *
     * Describes the attack path or mechanism that can be used to exploit the vulnerability.
     */
    std::string_view attackVector;

    /**
     * @brief Indicates whether authentication is required to exploit the vulnerability.
     *
     * Provides information on whether the attacker must be authenticated to exploit the vulnerability.
     */
    std::string_view authentication;

    /**
     * @brief Impact on the availability of the affected system.
     *
     * Describes the degree to which the vulnerability affects the availability of the system or component.
     */
    std::string_view availabilityImpact;

    /**
     * @brief Classification of the vulnerability.
     *
     * Typically denotes the category or type of the vulnerability (e.g., buffer overflow, SQL injection).
     */
    std::string_view classification;

    /**
     * @brief Impact on confidentiality due to the vulnerability.
     *
     * Describes how the vulnerability affects the confidentiality of the data or system.
     */
    std::string_view confidentialityImpact;

    /**
     * @brief CWE (Common Weakness Enumeration) identifier.
     *
     * The CWE ID associated with the vulnerability, which provides information about its underlying weakness.
     */
    std::string_view cweId;

    /**
     * @brief Date when the CVE entry was first published.
     *
     * Represents the original publication date of the CVE entry.
     */
    std::string_view datePublished;

    /**
     * @brief Date when the CVE entry was last updated.
     *
     * Represents the most recent update to the CVE entry.
     */
    std::string_view dateUpdated;

    /**
     * @brief Detailed description of the vulnerability.
     *
     * Provides an in-depth explanation of the vulnerability, including how it works and its potential impact.
     */
    std::string_view description;

    /**
     * @brief Impact on the integrity of the affected system.
     *
     * Describes how the vulnerability affects the integrity of the system or its data.
     */
    std::string_view integrityImpact;

    /**
     * @brief The level of privileges required to exploit the vulnerability.
     *
     * Indicates the privileges an attacker needs to have on the system to exploit the vulnerability.
     */
    std::string_view privilegesRequired;

    /**
     * @brief A reference to external documents or sources.
     *
     * Provides a reference to external information related to the vulnerability, such as advisories, reports, or
     * databases.
     */
    std::string_view reference;

    /**
     * @brief The scope of the impact.
     *
     * Describes whether the impact of the vulnerability is limited to the current component or extends to other
     * systems.
     */
    std::string_view scope;

    /**
     * @brief The base severity score of the vulnerability.
     *
     * Initialized to 0.0, this represents the severity of the vulnerability based on a scoring system such as CVSS.
     */
    float scoreBase = 0.0f;

    /**
     * @brief The version of the scoring system used to calculate the base score.
     *
     * Indicates which version of the scoring system (e.g., CVSS v3.1) was used to calculate the base score.
     */
    std::string_view scoreVersion;

    /**
     * @brief The severity level of the vulnerability.
     *
     * Represents the overall severity of the vulnerability (e.g., LOW, MEDIUM, HIGH).
     */
    std::string_view severity;

    /**
     * @brief Indicates whether user interaction is required to exploit the vulnerability.
     *
     * Describes whether the vulnerability can be exploited without user interaction or if user action is needed.
     */
    std::string_view userInteraction;
};

/**
 * @brief Descriptions helper class.
 */
class DescriptionsHelper final
{
private:
    template<typename TGlobalData = GlobalData>
    static std::pair<const std::string&, const std::string&>
    cvssAndDescriptionSources(const std::pair<std::string, std::string>& sources)
    {
        // Ex. sources = {"redhat", "redhat_8"}
        const auto& [adp, expandedAdp] = sources;

        nlohmann::json vendorConfig;
        if (TGlobalData::instance().vendorMaps().at(ADP_DESCRIPTIONS_MAP_KEY).contains(adp))
        {
            vendorConfig = TGlobalData::instance().vendorMaps().at(ADP_DESCRIPTIONS_MAP_KEY).at(adp);
        }
        else
        {
            // Fallback to default ADP
            vendorConfig = TGlobalData::instance().vendorMaps().at(ADP_DESCRIPTIONS_MAP_KEY).at(DEFAULT_ADP);
        }

        const auto& cvssSource = vendorConfig.at(ADP_CVSS_KEY).get_ref<const std::string&>();
        const auto& descriptionSource = vendorConfig.at(ADP_DESCRIPTION_KEY).get_ref<const std::string&>();

        return {cvssSource == adp ? expandedAdp : cvssSource,
                descriptionSource == adp ? expandedAdp : descriptionSource};
    }

public:
    template<typename TDatabaseFeedManager = DatabaseFeedManager, typename TGlobalData = GlobalData>
    static void vulnerabilityDescription(const std::string& cve,
                                         const std::pair<std::string, std::string>& sources,
                                         std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager,
                                         const std::function<void(const CveDescription&)>& callback)
    {
        FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription> descriptionData;
        FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription> cvssData;

        const auto& [cvssSource, descriptionSource] =
            DescriptionsHelper::cvssAndDescriptionSources<TGlobalData>(sources);

        // Get description data
        if (!databaseFeedManager->getVulnerabiltyDescriptiveInformation(cve, descriptionSource, descriptionData))
        {
            // Information not from source, try with default ADP
            databaseFeedManager->getVulnerabiltyDescriptiveInformation(cve, DEFAULT_ADP, cvssData);
        }

        // Get CVSS data
        if (cvssSource != descriptionSource)
        {
            if (!databaseFeedManager->getVulnerabiltyDescriptiveInformation(cve, descriptionSource, descriptionData))
            {
                // Information not from source, try with default ADP
                databaseFeedManager->getVulnerabiltyDescriptiveInformation(cve, DEFAULT_ADP, descriptionData);
            }
        }
        else
        {
            // If the sources are the same, cvssData will be the same as descriptionData
            cvssData.data = descriptionData.data;
        }

        // Call the callback function with the CveDescription object
        callback(CveDescription {cvssData.data->accessComplexity()->string_view(),
                                 descriptionData.data->assignerShortName()->string_view(),
                                 cvssData.data->attackVector()->string_view(),
                                 cvssData.data->authentication()->string_view(),
                                 cvssData.data->availabilityImpact()->string_view(),
                                 cvssData.data->classification()->string_view(),
                                 cvssData.data->confidentialityImpact()->string_view(),
                                 descriptionData.data->cweId()->string_view(),
                                 descriptionData.data->datePublished()->string_view(),
                                 descriptionData.data->dateUpdated()->string_view(),
                                 descriptionData.data->description()->string_view(),
                                 cvssData.data->integrityImpact()->string_view(),
                                 cvssData.data->privilegesRequired()->string_view(),
                                 descriptionData.data->reference()->string_view(),
                                 cvssData.data->scope()->string_view(),
                                 cvssData.data->scoreBase(),
                                 cvssData.data->scoreVersion()->string_view(),
                                 cvssData.data->severity()->string_view(),
                                 cvssData.data->userInteraction()->string_view()});
    }
};

#endif // _DESCRIPTIONS_HELPER_HPP
