/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * September 22, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */
#ifndef _DESCRIPTIONS_HELPER_HPP
#define _DESCRIPTIONS_HELPER_HPP

#include "databaseFeedManager.hpp"
#include "globalData.hpp"
#include "json.hpp"
#include <string>

struct CveDescription final
{
    std::string_view accessComplexity;
    std::string_view assignerShortName;
    std::string_view attackVector;
    std::string_view authentication;
    std::string_view availabilityImpact;
    std::string_view classification;
    std::string_view confidentialityImpact;
    std::string_view cweId;
    std::string_view datePublished;
    std::string_view dateUpdated;
    std::string_view description;
    std::string_view integrityImpact;
    std::string_view privilegesRequired;
    std::string_view reference;
    std::string_view scope;
    float scoreBase = 0.0f; // Initialize scoreBase to 0.0
    std::string_view scoreVersion;
    std::string_view severity;
    std::string_view userInteraction;
};

/**
 * @brief Descriptions helper class.
 */
class DescriptionsHelper final
{
private:
    template<typename TGlobalData = GlobalData>
    static std::pair<const std::string, const std::string>
    cvssAndDescriptionSources(const std::pair<std::string, std::string>& sources)
    {
        // Ex. sources = {"redhat", "redhat_8"}
        const auto& [adp, expandedAdp] = sources;

        nlohmann::json vendorConfig;
        if (TGlobalData::instance().vendorMaps().at(ADP_DESCRIPTIONS_MAP_KEY).contains(adp))
        {
            vendorConfig = TGlobalData::instance().vendorMaps().at(ADP_DESCRIPTIONS_MAP_KEY).at(adp);
        }
        else
        {
            // Fallback to default ADP
            vendorConfig = TGlobalData::instance().vendorMaps().at(ADP_DESCRIPTIONS_MAP_KEY).at(DEFAULT_ADP);
        }

        const auto& cvssSource = vendorConfig.at(ADP_CVSS_KEY).get_ref<const std::string&>();
        const auto& descriptionSource = vendorConfig.at(ADP_DESCRIPTION_KEY).get_ref<const std::string&>();

        return {cvssSource == adp ? expandedAdp : cvssSource,
                descriptionSource == adp ? expandedAdp : descriptionSource};
    }

public:
    template<typename TDatabaseFeedManager = DatabaseFeedManager, typename TGlobalData = GlobalData>
    static void vulnerabilityDescription(const std::string& cve,
                                         const std::pair<std::string, std::string>& sources,
                                         std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager,
                                         const std::function<void(const CveDescription&)>& callback)
    {
        FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription> descriptionData;
        FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription> cvssData;

        const auto [cvssSource, descriptionSource] =
            DescriptionsHelper::cvssAndDescriptionSources<TGlobalData>(sources);

        // Get description data
        if (!databaseFeedManager->getVulnerabiltyDescriptiveInformation(cve, descriptionSource, descriptionData))
        {
            // Information not from source, try with default ADP
            databaseFeedManager->getVulnerabiltyDescriptiveInformation(cve, DEFAULT_ADP, cvssData);
        }

        // Get CVSS data
        if (cvssSource != descriptionSource)
        {
            if (!databaseFeedManager->getVulnerabiltyDescriptiveInformation(cve, descriptionSource, descriptionData))
            {
                // Information not from source, try with default ADP
                databaseFeedManager->getVulnerabiltyDescriptiveInformation(cve, DEFAULT_ADP, descriptionData);
            }
        }
        else
        {
            // If the sources are the same, cvssData will be the same as descriptionData
            cvssData.data = descriptionData.data;
        }

        // Call the callback function with the CveDescription object
        callback(CveDescription {cvssData.data->accessComplexity()->string_view(),
                                 descriptionData.data->assignerShortName()->string_view(),
                                 cvssData.data->attackVector()->string_view(),
                                 cvssData.data->authentication()->string_view(),
                                 cvssData.data->availabilityImpact()->string_view(),
                                 cvssData.data->classification()->string_view(),
                                 cvssData.data->confidentialityImpact()->string_view(),
                                 descriptionData.data->cweId()->string_view(),
                                 descriptionData.data->datePublished()->string_view(),
                                 descriptionData.data->dateUpdated()->string_view(),
                                 descriptionData.data->description()->string_view(),
                                 cvssData.data->integrityImpact()->string_view(),
                                 cvssData.data->privilegesRequired()->string_view(),
                                 descriptionData.data->reference()->string_view(),
                                 cvssData.data->scope()->string_view(),
                                 cvssData.data->scoreBase(),
                                 cvssData.data->scoreVersion()->string_view(),
                                 cvssData.data->severity()->string_view(),
                                 cvssData.data->userInteraction()->string_view()});
    }
};

#endif // _DESCRIPTIONS_HELPER_HPP
