/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 25, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "descriptionsHelper_test.hpp"
#include "MockDatabaseFeedManager.hpp"
#include "MockGlobalData.hpp"
#include "TrampolineGlobalData.hpp"
#include "descriptionsHelper.hpp"
#include "vulnerabilityDescription_generated.h"
#include <json.hpp>

namespace
{
    const nlohmann::json ADP_DESCRIPTIONS =
        R"#(
    {
        "adp_descriptions": {
            "ADP_1": {
                "description": "A",
                "cvss": "A"
            },
            "ADP_2": {
                "description": "A",
                "cvss": "B"
            },
            "nvd": {
                "description": "nvd",
                "cvss": "nvd"
            }
        }
    }
)#"_json;

    const std::string CVE_ID = "CVE-1234-1234";
    const std::string ADP_INEXISTENT = "non_existent";
    const std::string ADP_CVSS_EQUALS_DESCRIPTION = "ADP_1";
    const std::string ADP_CVSS_DIFFERS_DESCRIPTION = "ADP_2";
    const std::string ADP_EXPANDED_POSTFIX = "_expanded";

    const auto createVulnerabilityDescriptiveInformation =
        [](FlatbufferDataPair<VulnerabilityDescription>& resultContainer)
    {
        flatbuffers::FlatBufferBuilder fbBuilder;
        const auto vulnerabilityDescriptiveInformation =
            NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                         "cvssData.accessComplexity",
                                                                         "descriptionData.assignerShortName",
                                                                         "cvssData.attackVector",
                                                                         "cvssData.authentication",
                                                                         "cvssData.availabilityImpact",
                                                                         "cvssData.classification",
                                                                         "cvssData.confidentialityImpact",
                                                                         "descriptionData.cweId",
                                                                         "descriptionData.datePublished",
                                                                         "descriptionData.dateUpdated",
                                                                         "descriptionData.description",
                                                                         "cvssData.integrityImpact",
                                                                         "cvssData.privilegesRequired",
                                                                         "descriptionData.reference",
                                                                         "cvssData.scope",
                                                                         0.0f,
                                                                         "cvssData.scoreVersion",
                                                                         "cvssData.severity",
                                                                         "cvssData.userInteraction");

        fbBuilder.Finish(vulnerabilityDescriptiveInformation);

        rocksdb::Slice slice(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
        resultContainer.data = NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data());
    };

    const auto validateVulnerabilityDescriptiveInformation = [](const CveDescription& description)
    {
        EXPECT_EQ(description.accessComplexity, "cvssData.accessComplexity");
        EXPECT_EQ(description.assignerShortName, "descriptionData.assignerShortName");
        EXPECT_EQ(description.attackVector, "cvssData.attackVector");
        EXPECT_EQ(description.authentication, "cvssData.authentication");
        EXPECT_EQ(description.availabilityImpact, "cvssData.availabilityImpact");
        EXPECT_EQ(description.classification, "cvssData.classification");
        EXPECT_EQ(description.confidentialityImpact, "cvssData.confidentialityImpact");
        EXPECT_EQ(description.cweId, "descriptionData.cweId");
        EXPECT_EQ(description.datePublished, "descriptionData.datePublished");
        EXPECT_EQ(description.dateUpdated, "descriptionData.dateUpdated");
        EXPECT_EQ(description.description, "descriptionData.description");
        EXPECT_EQ(description.integrityImpact, "cvssData.integrityImpact");
        EXPECT_EQ(description.privilegesRequired, "cvssData.privilegesRequired");
        EXPECT_EQ(description.reference, "descriptionData.reference");
        EXPECT_EQ(description.scope, "cvssData.scope");
        EXPECT_EQ(description.scoreBase, 0.0f);
        EXPECT_EQ(description.scoreVersion, "cvssData.scoreVersion");
        EXPECT_EQ(description.severity, "cvssData.severity");
        EXPECT_EQ(description.userInteraction, "cvssData.userInteraction");
    };

} // namespace

/**
 * @brief Attempt to retrieve the information from an ADP in which the CVSS and description are obtained from the same
 * source.
 *
 */
TEST_F(DescriptionsHelperTest, cvssAndDescriptionFromSameSource)
{
    // Prepare the mocks
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    spGlobalDataMock = std::make_shared<MockGlobalData>();

    const auto sources =
        std::make_pair(ADP_CVSS_EQUALS_DESCRIPTION, ADP_CVSS_EQUALS_DESCRIPTION + ADP_EXPANDED_POSTFIX);

    // Expect the database manager to be called with the default ADP
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabiltyDescriptiveInformation(CVE_ID, sources.second, testing::_))
        .WillOnce(::testing::Invoke(
            [&](const std::string&, const std::string&, FlatbufferDataPair<VulnerabilityDescription>& resultContainer)
            {
                createVulnerabilityDescriptiveInformation(resultContainer);
                return true;
            }));

    // We don't expect the database manager to be called with the default ADP
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabiltyDescriptiveInformation(CVE_ID, DEFAULT_ADP, testing::_))
        .Times(0);

    // The global data should be called to retrieve the ADP descriptions map
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::Return(ADP_DESCRIPTIONS));

    DescriptionsHelper::vulnerabilityDescription<MockDatabaseFeedManager, TrampolineGlobalData>(
        CVE_ID, sources, spDatabaseFeedManagerMock, validateVulnerabilityDescriptiveInformation);

    // Reset the mocks
    spDatabaseFeedManagerMock.reset();
}
